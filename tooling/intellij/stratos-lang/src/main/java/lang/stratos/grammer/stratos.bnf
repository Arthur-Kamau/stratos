{
    // Name and the location of the parser which will be generated.
    parserClass="lang.stratos.grammer.StratosParser"

    // All nodes will extend this class. This wraps AST node to a PSI node.
    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    // Prefix for all generated classes.
    psiClassPrefix="Stratos"
    // Suffix for implementation classes.
    psiImplClassSuffix="Impl"

    // Location to be used when generating PSI classes.
    psiPackage="lang.stratos.grammer.psi"
    // Location to be used when generating PSI implementation classes.
    psiImplPackage="lang.stratos.grammer.impl"

    // Element type holder class name. This class will be used extensively throughout the tutorial.
    elementTypeHolderClass="lang.stratos.grammer.StratosTypes"

    // Class which will be used to create internal nodes.
    elementTypeClass="lang.stratos.grammer.StratosElementType"
    // Class which will be used to create leaf nodes.
    tokenTypeClass="lang.stratos.grammer.StratosTokenType"

    tokens = [
        IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
        WHITE_SPACE = 'regexp:\s+'
        // reserved words
          ASSERT="assert"
          BREAK="break"
          CASE="case"
          CATCH="catch"
          CLASS="class"
          CONST="const"
          CONTINUE="continue"
          DEFAULT="default"
          DO="do"
          ELSE="else"
          ENUM="enum"
          EXTENDS="extends"
          FALSE="false"
          FINAL="final"
          FINALLY="finally"
          FOR="for"
          IF="if"
          IN="in"
          IS="is"
          NEW="new"
          NULL="null"
          RETHROW="rethrow"
          RETURN="return"
          SUPER="super"
          SWITCH="switch"
          THIS="this"
          THROW="throw"
          TRUE="true"
          TRY="try"
          VAR="var"
          VOID="void"
          WHILE="while"
          WITH="with"

        // BUILT_IN_IDENTIFIER
          ABSTRACT="abstract"
          AS="as"
          COVARIANT="covariant"
          DEFERRED="deferred"
          EXPORT="export"
          EXTENSION="extension"
          EXTERNAL="external"
          FACTORY="factory"
          GET="get"
          IMPLEMENTS="implements"
          IMPORT="import"
          LIBRARY="library"
          MIXIN="mixin"
          OPERATOR="operator"
          PART="part"
          SET="set"
          STATIC="static"
          TYPEDEF="typedef"

        // other
          ON="on"
          OF="of"
          NATIVE="native"
          SHOW="show"
          HIDE="hide"
          SYNC="sync"
          ASYNC="async"
          AWAIT="await"
          YIELD="yield"
          LATE="late"
          REQUIRED="required"

          LBRACE="{"
          RBRACE="}"
          LBRACKET="["
          RBRACKET="]"
          LPAREN="("
          RPAREN=")"
          SEMICOLON=";"
          MINUS="-"
          MINUS_EQ="-="
          MINUS_MINUS="--"
          PLUS="+"
          PLUS_PLUS="++"
          PLUS_EQ="+="
          DIV="/"
          DIV_EQ="/="
          MUL="*"
          MUL_EQ="*="
          INT_DIV="~/"
          INT_DIV_EQ="~/="
          REM_EQ="%="
          REM="%"
          BIN_NOT="~"
          NOT="!"

          EXPRESSION_BODY_DEF="=>"
          EQ="="
          EQ_EQ="=="
          NEQ="!="
          DOT="."
          DOT_DOT=".."
          QUEST_DOT_DOT="?.."
          DOT_DOT_DOT="..."
          DOT_DOT_DOT_QUEST="...?"
          COMMA=","
          COLON=":"
          GT=">"
          GT_EQ=">="
          GT_GT=">>"
          GT_GT_EQ=">>="
          LT="<"
          LT_EQ="<="
          LT_LT="<<"
          LT_LT_EQ="<<="
          OR="|"
          OR_EQ="|="
          OR_OR="||"
          OR_OR_EQ="||="
          QUEST="?"
          QUEST_DOT="?."
          QUEST_QUEST="??"
          QUEST_QUEST_EQ="??="
          XOR="^"
          XOR_EQ="^="
          AND="&"
          AND_EQ="&="
          AND_AND="&&"
          AND_AND_EQ="&&="
          HASH="#"
          AT="@"
    ]
}

StratosFile ::= Definition*

Definition ::= FunctionDefinition

FunctionDefinition ::= function IDENTIFIER '(' ')' (returns Type)? '{' FunctionBody '}'

FunctionBody ::= Statement*

Statement ::= VariableDefinition | AssignmentStatement | FunctionInvocation

VariableDefinition ::= Type IDENTIFIER (';' | ('=' FunctionInvocation)?)

Type ::= int | string | number | double

AssignmentStatement ::= IDENTIFIER '=' FunctionInvocation

FunctionInvocation ::= IDENTIFIER '(' ')' ';'
