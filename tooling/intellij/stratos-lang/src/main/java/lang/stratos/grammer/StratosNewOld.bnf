{
  parserClass="lang.stratos.grammer.parser.StratosParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Stratos"
  psiImplClassSuffix="Impl"
  psiPackage="lang.stratos.grammer.psi"
  psiImplPackage="lang.stratos.grammer.psi.impl"

  elementTypeHolderClass="lang.stratos.grammer.types.StratosTypes"
  elementTypeClass="lang.stratos.grammer.StratosElementType"
  tokenTypeClass="lang.stratos.grammer.StratosTokenType"

  psiImplUtilClass="lang.stratos.grammer.StratosPsiImplUtil"

   tokens = [
          IDENTIFIER = 'regexp:[a-zA-Z_][a-zA-Z0-9_]*'
          WHITE_SPACE = 'regexp:\s+'
          // reserved words
            ASSERT="assert"
            BREAK="break"
            CASE="case"
            CATCH="catch"
            CLASS="class"
            CONST="const"
            CONTINUE="continue"
            DEFAULT="default"
            DO="do"
            ELSE="else"
            ENUM="enum"
            EXTENDS="extends"
            FALSE="false"
            FINAL="final"
            FINALLY="finally"
            FOR="for"
            IF="if"
            IN="in"
            IS="is"
            NEW="new"
            NULL="null"
            RETHROW="rethrow"
            RETURN="return"
            SUPER="super"
            SWITCH="switch"
            THIS="this"
            THROW="throw"
            TRUE="true"
            TRY="try"
            VAR="var"
            VOID="void"
            WHILE="while"
            WITH="with"

          // BUILT_IN_IDENTIFIER
            ABSTRACT="abstract"
            AS="as"
            COVARIANT="covariant"
            DEFERRED="deferred"
            EXPORT="export"
            EXTENSION="extension"
            EXTERNAL="external"
            FACTORY="factory"
            GET="get"
            IMPLEMENTS="implements"
            IMPORT="import"
            LIBRARY="library"
            MIXIN="mixin"
            OPERATOR="operator"
            PART="part"
            SET="set"
            STATIC="static"
            TYPEDEF="typedef"

          // other
            ON="on"
            OF="of"
            NATIVE="native"
            SHOW="show"
            HIDE="hide"
            SYNC="sync"
            ASYNC="async"
            AWAIT="await"
            YIELD="yield"
            LATE="late"
            REQUIRED="required"

            LBRACE="{"
            RBRACE="}"
            LBRACKET="["
            RBRACKET="]"
            LPAREN="("
            RPAREN=")"
            SEMICOLON=";"
            MINUS="-"
            MINUS_EQ="-="
            MINUS_MINUS="--"
            PLUS="+"
            PLUS_PLUS="++"
            PLUS_EQ="+="
            DIV="/"
            DIV_EQ="/="
            MUL="*"
            MUL_EQ="*="
            INT_DIV="~/"
            INT_DIV_EQ="~/="
            REM_EQ="%="
            REM="%"
            BIN_NOT="~"
            NOT="!"

            EXPRESSION_BODY_DEF="=>"
            EQ="="
            EQ_EQ="=="
            NEQ="!="
            DOT="."
            DOT_DOT=".."
            QUEST_DOT_DOT="?.."
            DOT_DOT_DOT="..."
            DOT_DOT_DOT_QUEST="...?"
            COMMA=","
            COLON=":"
            GT=">"
            GT_EQ=">="
            GT_GT=">>"
            GT_GT_EQ=">>="
            LT="<"
            LT_EQ="<="
            LT_LT="<<"
            LT_LT_EQ="<<="
            OR="|"
            OR_EQ="|="
            OR_OR="||"
            OR_OR_EQ="||="
            QUEST="?"
            QUEST_DOT="?."
            QUEST_QUEST="??"
            QUEST_QUEST_EQ="??="
            XOR="^"
            XOR_EQ="^="
            AND="&"
            AND_EQ="&="
            AND_AND="&&"
            AND_AND_EQ="&&="
            HASH="#"
            AT="@"
            COMMENT="//"
      ]
}

StratosFile ::=   Definition*


//stratosUnit ::= topLevelDefinition*
//private topLevelDefinition ::= Definition* // partOfStatement | importStatement
//                             | importStatement
//                             | exportStatement
//                             | partStatement
//                             | classDefinition
//                             | mixinDeclaration
//                             | enumDefinition
////                             | extensionDeclaration
////                             | functionTypeAlias
//                             | getterOrSetterDeclaration
//                             | functionDeclarationWithBodyOrNative
//                             | varDeclarationListWithSemicolon
//                             | incompleteDeclaration // not valid according to spec, but we'd like it to be parsed in order to have completion
//
//                             {recoverWhile="top_level_recover"}
//
//incompleteDeclaration ::= metadata* ('external' | 'static' | 'final' | 'const' | 'covariant')* type | metadata+;
//
//private finalOrConst ::= 'final' | 'const'
//private varDeclarationListWithSemicolon ::= varDeclarationList ';'{pin=1}
//partOfStatement ::= metadata* 'part' 'of' (libraryId | uriElement)';' {
//  pin=4
//  methods = [ getLibraryName getLibraryFiles]
//}
//partStatement ::= metadata* 'part' uriElement ';' {
//  pin=3
//  implements="lang.stratos.grammer.parser.psi.StratosUriBasedDirective"
//  methods = [ getUriString ]
//}
//importStatement ::= metadata* 'import' uriElement importConfig* ('deferred'? 'as' componentName )? combinator* ';' {
//  pin=3
//  implements="lang.stratos.grammer.parser.psi.StratosImportOrExportStatement"
//  methods = [
//    getUriString
//    importPrefix = "componentName"
//  ]
//}
//
//exportStatement ::= metadata* 'export' uriElement importConfig* combinator* ';' {
//  pin=3
//  implements="lang.stratos.grammer.parser.psi.StratosImportOrExportStatement"
//  methods = [ getUriString ]
//}
//
//
//classDefinition ::= metadata* 'abstract'? 'class' componentName typeParameters? (mixinApplication | standardClassDeclarationTail)
//{pin=4 mixin="lang.stratos.grammer.parser.psi.impl.AbstractStratosPsiClass" implements="lang.stratos.grammer.parser.psi.StratosClass"}
//
//mixinDeclaration ::= metadata* 'mixin' componentName typeParameters? onMixins? interfaces? classBody
//{mixin="lang.stratos.grammer.parser.psi.impl.AbstractStratosPsiClass" implements="lang.stratos.grammer.parser.psi.StratosClass"}
//
//enumDefinition ::= metadata* 'enum' componentName '{' enumConstantDeclaration (',' enumConstantDeclaration)* ','? '}'
//{pin=3  mixin="lang.stratos.grammer.parser.psi.impl.AbstractStratosPsiClass" implements="lang.stratos.grammer.parser.psi.StratosClass"}
//
//enumConstantDeclaration ::= componentName
//{
//  mixin="lang.stratos.grammer.parser.psi.impl.AbstractStratosComponentImpl"
//  implements="lang.stratos.grammer.parser.psi.StratosComponent"
//  methods = [getMetadataList]
//}
//
//functionExpression ::= typeParameters? formalParameterList functionExpressionBody
//{mixin="lang.stratos.grammer.parser.psi.impl.StratosFunctionExpressionBase"}
//functionDeclarationWithBodyOrNative ::= metadata* 'external'? (returnType componentName typeParameters? formalParameterList | componentName typeParameters? formalParameterList) ( ';' | functionBodyOrNative)
//{mixin="lang.stratos.grammer.parser.psi.impl.AbstractStratosComponentImpl" implements="lang.stratos.grammer.parser.psi.StratosComponent"}
//functionDeclarationWithBody ::= metadata*  (returnType componentName typeParameters? formalParameterList | componentName typeParameters? formalParameterList) functionBody // todo merge with functionDeclarationWithBodyOrNative
//{mixin="lang.stratos.grammer.parser.psi.impl.AbstractStratosComponentImpl" implements="lang.stratos.grammer.parser.psi.StratosComponent"}







Definition ::=  ClassDefinition | NameSpaceDefinition  | FunctionDefinition



ClassDefinition ::= class IDENTIFIER  '{' FunctionBody | Statement*  '}'

NameSpaceDefinition ::= namespace IDENTIFIER  '{' FunctionBody | Statement*  '}'

FunctionDefinition ::= function IDENTIFIER '(' ')' (returns Type)? '{' FunctionBody '}'

FunctionBody ::= Statement*

Statement ::= VariableDefinition | AssignmentStatement | FunctionInvocation

VariableDefinition ::= variableDeclarationWithTypes | variableDeclarationWithoutTypes

variableDeclarationWithTypes  ::=  variableDeclaration IDENTIFIER ':' Type (';' | ('=' FunctionInvocation)?)

//ArrayOrSliceType ::= '[' Type(IDENTIFIER) ']'


variableDeclarationWithoutTypes  ::=  variableDeclaration IDENTIFIER '=' (ArrayOrSliceType ) ';'

variableDeclaration ::= var | val | let

Type ::= int | string | number | double

AssignmentStatement ::= IDENTIFIER '=' FunctionInvocation

FunctionInvocation ::= IDENTIFIER '(' ')' ';'


//{
//    // Name and the location of the parser which will be generated.
//    parserClass="lang.stratos.grammer.StratosParser"
//
//    // All nodes will extend this class. This wraps AST node to a PSI node.
//    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"
//
//    // Prefix for all generated classes.
//    psiClassPrefix="Stratos"
//    // Suffix for implementation classes.
//    psiImplClassSuffix="Impl"
//
//    // Location to be used when generating PSI classes.
//    psiPackage="lang.stratos.grammer.psi"
//    // Location to be used when generating PSI implementation classes.
//    psiImplPackage="lang.stratos.grammer.impl"
//
//    // Element type holder class name. This class will be used extensively throughout the tutorial.
//    elementTypeHolderClass="lang.stratos.grammer.StratosTypes"
//
//    // Class which will be used to create internal nodes.
//    elementTypeClass="lang.stratos.grammer.StratosElementType"
//    // Class which will be used to create leaf nodes.
//    tokenTypeClass="lang.stratos.grammer.StratosTokenType"
//

//}
//
//StratosFile ::= Definition*
//
//Definition ::= FunctionDefinition
//
//FunctionDefinition ::= function IDENTIFIER '(' ')' (returns Type)? '{' FunctionBody '}'
//
//FunctionBody ::= Statement*
//
//Statement ::= VariableDefinition | AssignmentStatement | FunctionInvocation
//
//VariableDefinition ::= Type IDENTIFIER (';' | ('=' FunctionInvocation)?)
//
//Type ::= int | string | number | double
//
//AssignmentStatement ::= IDENTIFIER '=' FunctionInvocation
//
//FunctionInvocation ::= IDENTIFIER '(' ')' ';'
